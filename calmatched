import re
import numpy as np
import pandas as pd

# unicode fraction map (½, ¼, ¾, etc.)
_FRAC = {"¼":0.25,"½":0.5,"¾":0.75,"⅐":1/7,"⅑":1/9,"⅒":0.1,
         "⅓":1/3,"⅔":2/3,"⅕":0.2,"⅖":0.4,"⅗":0.6,"⅘":0.8,
         "⅙":1/6,"⅚":5/6,"⅛":0.125,"⅜":0.375,"⅝":0.625,"⅞":0.875}

def _norm_coupon_piece(s: str) -> float:
    s = s.strip().replace("%","")
    # e.g. "4½", "0 5/8" (rare), "4.5"
    # 1) unicode fraction form like "4½" or just "½"
    m = re.fullmatch(r"\s*(\d+)?\s*([¼½¾⅐⅑⅒⅓⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞])?\s*", s)
    if m and (m.group(1) or m.group(2)):
        whole = float(m.group(1)) if m.group(1) else 0.0
        frac  = _FRAC.get(m.group(2), 0.0)
        return whole + frac
    # 2) decimal like "4.5"
    return float(s)

def extract_coupon_from_title(title: str) -> float | None:
    if not isinstance(title, str):
        return None
    # capture either a decimal number or an integer+unicode fraction before '%'
    m = re.search(r"([0-9]+(?:\.[0-9]+)?)%|([0-9\s¼½¾⅐⅑⅒⅓⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞]+)%", title)
    if not m:
        return None
    raw = m.group(1) or m.group(2)
    return _norm_coupon_piece(raw)

# add coupon_pct to your calendar_df
calendar_df = calendar_df.copy()
calendar_df["coupon_pct"] = calendar_df["security_name"].apply(extract_coupon_from_title)




# ensure floats are comparable (avoid 4.5 vs 4.50 issues)
def _isclose(a, b, tol=1e-6):
    return (pd.notna(a) and pd.notna(b) and np.isfinite(a) and np.isfinite(b)
            and abs(float(a) - float(b)) <= tol)

# create a lightweight series meta
series_meta = (gilt_df
               .drop_duplicates(["series_id","coupon_pct","maturity_year"])
               [["series_id","coupon_pct","maturity_year"]]
              ).reset_index(drop=True)

def pick_series(row):
    # filter quickly on maturity year first
    cands = series_meta[series_meta["maturity_year"] == row["maturity_year"]]
    if cands.empty or pd.isna(row["coupon_pct"]):
        return None
    # float-safe coupon match
    cands = cands[[ _isclose(row["coupon_pct"], c) for c in cands["coupon_pct"] ]]
    if cands.empty:
        return None
    # optional: require coverage on auction_dt
    # find those whose gilt_df date range covers auction_dt
    bids = []
    for sid in cands["series_id"]:
        g = gilt_df[gilt_df["series_id"] == sid]
        if not g.empty and g["date"].min() <= row["auction_dt"] <= g["date"].max():
            bids.append(sid)
    return bids[0] if bids else None

calendar_df["series_id"] = calendar_df.apply(pick_series, axis=1)
cal_matched = calendar_df.dropna(subset=["series_id"]).reset_index(drop=True)

OR


# prefer exact date match
series_meta = gilt_df.drop_duplicates(["series_id","coupon_pct","maturity_date","maturity_year"])

def pick_series_exact(row):
    if pd.notna(row.get("maturity_date", pd.NA)):
        cands = series_meta[
            (series_meta["maturity_date"] == row["maturity_date"])
            & (series_meta["coupon_pct"].apply(lambda c: _isclose(c, row["coupon_pct"])))
        ]
    else:
        cands = series_meta[
            (series_meta["maturity_year"] == row["maturity_year"])
            & (series_meta["coupon_pct"].apply(lambda c: _isclose(c, row["coupon_pct"])))
        ]
    if cands.empty:
        return None
    # coverage check
    for sid in cands["series_id"]:
        g = gilt_df[gilt_df["series_id"] == sid]
        if not g.empty and g["date"].min() <= row["auction_dt"] <= g["date"].max():
            return sid
    return None

calendar_df["series_id"] = calendar_df.apply(pick_series_exact, axis=1)
cal_matched = calendar_df.dropna(subset=["series_id"]).reset_index(drop=True)
